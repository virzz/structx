package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/fs"
	"os"
	"strings"
)

type Struct struct {
	Name   string
	Fields map[string]string
}

func toTitle(s string) string {
	return strings.ToUpper(s[:1]) + s[1:]
}

func getFieldTypeName(e ast.Expr) string {
	switch ft := e.(type) {
	case *ast.StarExpr:
		return "*" + getFieldTypeName(ft.X)
	case *ast.ArrayType:
		return "[]" + getFieldTypeName(ft.Elt)
	case *ast.MapType:
		return "map[" + getFieldTypeName(ft.Key) + "]" + getFieldTypeName(ft.Value)
	case *ast.SelectorExpr:
		return getFieldTypeName(ft.X) + "." + getFieldTypeName(ft.Sel)
	case *ast.Ident:
		return ft.Name
	case *ast.StructType:
		return "struct{}"
	default:
		fmt.Fprintf(os.Stderr, "unknown type: %+v\n", ft)
		return "unknown"
	}
}

func parseStruct(s *[]Struct, f *ast.File) error {
	fields := map[string]string{}
	for _, node := range f.Decls {
		genDecl, ok := node.(*ast.GenDecl)
		if !ok {
			continue
		}
		for _, spec := range genDecl.Specs {
			ts, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			st, ok := ts.Type.(*ast.StructType)
			if !ok || ts.Name.Name != *structName {
				continue
			}
			for _, _s := range *s {
				if _s.Name == ts.Name.Name {
					continue
				}
			}
			for _, field := range st.Fields.List {
				ft := getFieldTypeName(field.Type)
				for _, name := range field.Names {
					fields[name.Name] = ft
				}
			}
			*s = append(*s, Struct{Name: ts.Name.Name, Fields: fields})
		}
	}
	return nil
}

var (
	fileName   = flag.String("file", "", "file name")
	structName = flag.String("struct", "", "struct name")
)

var (
	structs = []Struct{}
	fset    = token.NewFileSet()
)

func main() {
	flag.Parse()
	if *structName == "" {
		fmt.Fprintln(os.Stderr, "struct name is required")
		return
	}
	pkgs, err := parser.ParseDir(fset, ".", func(fi fs.FileInfo) bool {
		return !(*fileName != "" && fi.Name() != *fileName)
	}, parser.ParseComments)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}
	// Get struct info
	buf := bytes.Buffer{}
	for _, pkg := range pkgs {
		for _, f := range pkg.Files {
			if err := parseStruct(&structs, f); err != nil {
				fmt.Fprintln(os.Stderr, err)
				continue
			}
			for _, s := range structs {
				buf.Reset()
				buf.WriteString("// Code generated by github.com/virzz/structx. DO NOT EDIT.\n\n")
				buf.WriteString("package " + f.Name.Name + "\n\n")
				for name, typ := range s.Fields {
					if name[0] != strings.ToLower(name)[0] {
						continue
					}
					buf.WriteString("func (s *" + s.Name + ") With" + toTitle(name) + "(v " + typ + ") { s." + name + " = v }\n")
				}
				buf.WriteString("\n")
				for name, typ := range s.Fields {
					if name[0] == strings.ToLower(name)[0] {
						continue
					}
					buf.WriteString("func (s *" + s.Name + ") With" + toTitle(name) + "(v " + typ + ") { s." + name + " = v }\n")
				}
				// Generate struct methods
				data, err := format.Source(buf.Bytes())
				if err != nil {
					fmt.Fprintln(os.Stderr, err)
					return
				}
				genName := strings.ToLower(s.Name + ".structx.go")
				err = os.WriteFile(genName, data, 0o644)
				if err != nil {
					fmt.Fprintln(os.Stderr, err)
					return
				}
				fmt.Println("Generated struct methods for", s.Name)
			}
		}
	}
}
